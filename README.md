# Лабораторные работы по курсу "Системы реального времени"

## Лабораторная работа №1: Основы POSIX и синхронизация

**Цель:** Изучение механизмов создания потоков и организации доступа к общим ресурсам в Linux.

**Реализованные задачи:**
1. **Потоки (Threads):** Создание и управление потоками (`pthread_create`, `join`).
2. **Синхронизация:**
   - Решение проблемы "Гонки данных" (Race Condition) с помощью мьютексов (`pthread_mutex`).
   - Использование семафоров и условных переменных (`condvar`) для координации потоков.
3. **Классические проблемы:**
   - Реализация паттерна "Производитель-Потребитель".
   - Демонстрация и решение проблемы "Инверсии приоритетов" (Priority Inversion) через наследование приоритетов.
4. **Обработка сигналов:** Перехват системных прерываний (`SIGINT`, `SIGTERM`) и безопасное завершение программ.
5. **Менеджер ресурсов:** Разработка клиент-серверного приложения на сокетах (`AF_UNIX`), реализующего доступ к общему строковому ресурсу (команды READ/WRITE).


# Отчет по Лабораторной работе №2

## Результаты измерений (sched_fifo_jitter)
**Среда выполнения:** WSL2 (Windows Subsystem for Linux)

1. **Без оптимизаций (SCHED_OTHER):**
   - Max Latency: ~698 us (698948 ns)
   - Avg Latency: ~35 us

2. **С оптимизациями (SCHED_FIFO, Priority 50, mlockall, CPU affinity):**
   - Max Latency: ~513 us (513525 ns)
   - Avg Latency: ~24 us

**Вывод:** Применение механизмов реального времени (вытесняющий планировщик, блокировка памяти, привязка к ядру) позволило снизить максимальную задержку (jitter) и улучшить стабильность системы, даже в условиях виртуализации.

## Ответы на контрольные вопросы

### 1. Сравнение clock_nanosleep и nanosleep
**Вопрос:** Почему `clock_nanosleep` с абсолютным временем предпочтительнее?
**Ответ:** 
`clock_nanosleep` с флагом `TIMER_ABSTIME` позволяет указать точную точку во времени для пробуждения (например, "проснуться ровно в момент T"). Если поток проснется с задержкой, следующее время пробуждения (T + Period) не сдвинется.
Функция `nanosleep` использует относительное время ("спать X секунд"). Любая задержка пробуждения добавляется к следующему циклу, вызывая накопление ошибки (дрейф/drift).

### 2. timerfd vs Сигналы
**Вопрос:** Почему `timerfd` надежнее?
**Ответ:**
`timerfd` создает файловый дескриптор, который можно мониторить через `poll`, `select` или `epoll`. Это позволяет встроить таймер в общий цикл обработки событий (Event Loop) вместе с сетью и вводом-выводом.
Сигналы (через `timer_create`) прерывают выполнение программы асинхронно. Это создает риск гонок данных (race conditions) и сильно ограничивает список функций, которые можно безопасно вызывать внутри обработчика (только async-signal-safe функции).

### 3. Инверсия приоритетов
**Вопрос:** Сценарий возникновения и решение.
**Ответ:**
Сценарий: Низкоприоритетный поток (L) захватил мьютекс. Высокоприоритетный поток (H) ждет этот мьютекс. Среднеприоритетный поток (M) начинает работать и вытесняет L (так как M > L). В итоге L не может доделать работу и освободить мьютекс, а H вынужден ждать, пока отработает M.
Решение: Использовать атрибут мьютекса `PTHREAD_PRIO_INHERIT`. В этом случае, когда H начинает ждать мьютекс, поток L временно получает приоритет потока H, чтобы быстро завершить работу и освободить ресурс.

### 4. Предсказуемость vs Производительность
**Вопрос:** Почему оптимизации снижают общую производительность?
**Ответ:**
Использование `SCHED_FIFO` и жесткая привязка к ядру (CPU Affinity) мешают планировщику ОС эффективно распределять нагрузку.
- Привязка к ядру может оставить одно ядро перегруженным, а другие пустыми.
- Высокий приоритет FIFO может блокировать фоновые системные процессы.
Это снижает общую пропускную способность (throughput), но гарантирует минимальную задержку (latency) для конкретной важной задачи.

### 5. Жесткое реальное время
**Вопрос:** Достаточно ли этих техник для жесткого РВ? Что такое PREEMPT_RT?
**Ответ:**
Стандартного ядра Linux недостаточно для **жесткого** реального времени, так как внутри ядра существуют секции с отключенными прерываниями (спинлоки), которые могут создавать непредсказуемые задержки.
`PREEMPT_RT` — это набор патчей (Real-Time Patch), который:
1. Заменяет спинлоки на мьютексы (делает ядро вытесняемым).
2. Позволяет прерывать обработчики прерываний.
Это гарантирует детерминированное время реакции системы.

---
# Отчет по Лабораторной работе №3: Механизмы IPC

**Цель:** Освоение методов межпроцессного взаимодействия в Linux.

**Реализованные задачи:**
1. **POSIX Message Queues:** Клиент-серверное приложение. Демонстрация приоритетной обработки (сообщения с высоким приоритетом обрабатываются раньше).
2. **Epoll Server:** Асинхронный сервер (single-thread), способный держать тысячи соединений. Реализован Edge-Triggered режим и внутренние уведомления через `eventfd`.
3. **Векторный I/O (readv/writev):** Оптимизация передачи структур данных без лишнего копирования (Zero-Copy в user-space).
4. **Shared Memory:** Самый быстрый способ передачи данных. Реализован кольцевой буфер с защитой целостности через пару семафоров (Producer-Consumer).

## Ответы на контрольные вопросы

### 1. POSIX MQ vs UNIX Sockets
**Вопрос:** Когда использовать MQ, а когда Сокеты?
**Ответ:**
*   **Message Queues:** Идеальны, когда нужны *приоритеты* сообщений и гарантия границ сообщений (не нужно парсить поток байт). Хорошо подходят для локальных управляющих команд (например, "Остановиться", "Срочная задача").
*   **UNIX Sockets:** Лучший выбор для передачи *потоков данных* (stream) или больших объемов информации. Также предпочтительны, если нужно использовать стандартные инструменты (nc, socat, nginx) или переносить код на сетевые сокеты в будущем.

### 2. Epoll: Edge-Triggered (ET) vs Level-Triggered (LT)
**Вопрос:** В чем разница и риски ET?
**Ответ:**
*   **LT (Level-Triggered, по умолчанию):** `epoll` будит процесс постоянно, пока в буфере есть данные. Это надежнее (труднее "потерять" событие).
*   **ET (Edge-Triggered):** `epoll` будит процесс *только один раз*, в момент прихода новых данных.
*   **Сложность ET:** Если программа не вычитает все данные до конца (до ошибки `EAGAIN`), `epoll` больше не уведомит о наличии остатка, и соединение "зависнет". Требует неблокирующих сокетов и циклов чтения.

### 3. Семафоры vs Мьютексы в Shared Memory
**Вопрос:** Можно ли использовать мьютекс вместо семафоров между процессами?
**Ответ:**
Обычный `pthread_mutex_t` работает только внутри одного процесса (между потоками). Чтобы использовать его между *разными* процессами в общей памяти, его нужно инициализировать со специальным атрибутом:
`pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);`
Если этого не сделать, синхронизация работать не будет. Семафоры (`sem_open`) изначально созданы для межпроцессного взаимодействия, поэтому их использовать проще.

### 4. Копирование данных (Overhead)
**Вопрос:** Расположите по возрастанию копирований.
**Ответ:**
1.  **Shared Memory (0 копий):** Данные вообще не копируются ядром. Процессы видят одни и те же физические страницы памяти. Самый быстрый способ.
2.  **UNIX Sockets / Pipes (~2 копии):** User-Space (Process A) -> Kernel Buffer -> User-Space (Process B). Можно оптимизировать через `splice` или `vmsplice`.
3.  **Message Queues (~2 копии + накладные расходы):** Тоже копирование через ядро, но часто добавляется overhead на сортировку по приоритетам и управление структурой очереди.

---
# Отчет по Лабораторной работе №4: Работа с устройствами ввода

**Цель:** Изучение подсистемы ввода Linux (Input Subsystem) и мультиплексирования ввода-вывода.

**Реализованные задачи:**
1. **Чтение событий (`read`):** Программа читает структуры `struct input_event` напрямую из файла устройства `/dev/input/eventX`.
2. **Управление устройством (`ioctl`):** Получение имени устройства (EVIOCGNAME) и физического расположения через системный вызов `ioctl`.
3. **Мультиплексирование (`poll`):** Одновременный мониторинг нескольких устройств ввода в одном потоке. Использование флага `O_NONBLOCK` для предотвращения блокировок.

## Ответы на контрольные вопросы

### 1. Символьные vs Блочные устройства
**Вопрос:** В чем отличие и примеры?
**Ответ:**
*   **Символьные (Character devices):** Предоставляют доступ к данным как к потоку байтов (последовательно). Обычно не используют буферизацию (данные читаются по мере поступления).
    *   *Примеры:* Клавиатура, мышь, `/dev/tty` (терминал), `/dev/urandom`.
*   **Блочные (Block devices):** Предоставляют доступ к данным блоками фиксированного размера (секторами). Позволяют произвольный доступ (seek) и используют кэширование ОС.
    *   *Примеры:* Жесткий диск (`/dev/sda`), USB-флешка, SSD.

### 2. poll() vs Busy-wait
**Вопрос:** Почему `poll` лучше цикла опроса?
**Ответ:**
Цикл `busy-wait` (постоянная проверка "есть ли данные?") загружает процессор на 100%, расходуя энергию и мешая другим задачам.
Системный вызов `poll()` переводит процесс в состояние сна (блокировки), пока ядро не уведомит о наступлении события. Это критически важно в многозадачных системах и для экономии батареи.

### 3. Блокирующий read()
**Вопрос:** Может ли `read` заблокировать процесс и как избежать?
**Ответ:**
Да, по умолчанию чтение из символьного устройства блокирует процесс, пока не придут данные (например, пока пользователь не нажмет кнопку).
Избежать этого можно двумя способами:
1. Открывать файл с флагом `O_NONBLOCK`. Тогда `read` вернет ошибку `EAGAIN`, если данных нет.
2. Использовать `poll`/`select` перед вызовом `read`, чтобы убедиться, что данные готовы.

### 4. Переносимость (Portability)
**Вопрос:** Переносим ли код с `linux/input.h` на другие POSIX-системы?
**Ответ:**
Нет. Структуры `input_event` и команды `ioctl` (типа `EVIOCGNAME`) специфичны для ядра Linux.
В других UNIX-системах (macOS, FreeBSD) работа с сырым вводом реализована иначе (другие заголовки, другие структуры). Для кроссплатформенности нужно использовать библиотеки-обертки (например, `libevdev` или `SDL`).