# Лабораторные работы по курсу "Системы реального времени"

## Лабораторная работа №1: Основы POSIX и синхронизация

**Цель:** Изучение механизмов создания потоков и организации доступа к общим ресурсам в Linux.

**Реализованные задачи:**
1. **Потоки (Threads):** Создание и управление потоками (`pthread_create`, `join`).
2. **Синхронизация:**
   - Решение проблемы "Гонки данных" (Race Condition) с помощью мьютексов (`pthread_mutex`).
   - Использование семафоров и условных переменных (`condvar`) для координации потоков.
3. **Классические проблемы:**
   - Реализация паттерна "Производитель-Потребитель".
   - Демонстрация и решение проблемы "Инверсии приоритетов" (Priority Inversion) через наследование приоритетов.
4. **Обработка сигналов:** Перехват системных прерываний (`SIGINT`, `SIGTERM`) и безопасное завершение программ.
5. **Менеджер ресурсов:** Разработка клиент-серверного приложения на сокетах (`AF_UNIX`), реализующего доступ к общему строковому ресурсу (команды READ/WRITE).


# Отчет по Лабораторной работе №2

## Результаты измерений (sched_fifo_jitter)
**Среда выполнения:** WSL2 (Windows Subsystem for Linux)

1. **Без оптимизаций (SCHED_OTHER):**
   - Max Latency: ~698 us (698948 ns)
   - Avg Latency: ~35 us

2. **С оптимизациями (SCHED_FIFO, Priority 50, mlockall, CPU affinity):**
   - Max Latency: ~513 us (513525 ns)
   - Avg Latency: ~24 us

**Вывод:** Применение механизмов реального времени (вытесняющий планировщик, блокировка памяти, привязка к ядру) позволило снизить максимальную задержку (jitter) и улучшить стабильность системы, даже в условиях виртуализации.

## Ответы на контрольные вопросы

### 1. Сравнение clock_nanosleep и nanosleep
**Вопрос:** Почему `clock_nanosleep` с абсолютным временем предпочтительнее?
**Ответ:** 
`clock_nanosleep` с флагом `TIMER_ABSTIME` позволяет указать точную точку во времени для пробуждения (например, "проснуться ровно в момент T"). Если поток проснется с задержкой, следующее время пробуждения (T + Period) не сдвинется.
Функция `nanosleep` использует относительное время ("спать X секунд"). Любая задержка пробуждения добавляется к следующему циклу, вызывая накопление ошибки (дрейф/drift).

### 2. timerfd vs Сигналы
**Вопрос:** Почему `timerfd` надежнее?
**Ответ:**
`timerfd` создает файловый дескриптор, который можно мониторить через `poll`, `select` или `epoll`. Это позволяет встроить таймер в общий цикл обработки событий (Event Loop) вместе с сетью и вводом-выводом.
Сигналы (через `timer_create`) прерывают выполнение программы асинхронно. Это создает риск гонок данных (race conditions) и сильно ограничивает список функций, которые можно безопасно вызывать внутри обработчика (только async-signal-safe функции).

### 3. Инверсия приоритетов
**Вопрос:** Сценарий возникновения и решение.
**Ответ:**
Сценарий: Низкоприоритетный поток (L) захватил мьютекс. Высокоприоритетный поток (H) ждет этот мьютекс. Среднеприоритетный поток (M) начинает работать и вытесняет L (так как M > L). В итоге L не может доделать работу и освободить мьютекс, а H вынужден ждать, пока отработает M.
Решение: Использовать атрибут мьютекса `PTHREAD_PRIO_INHERIT`. В этом случае, когда H начинает ждать мьютекс, поток L временно получает приоритет потока H, чтобы быстро завершить работу и освободить ресурс.

### 4. Предсказуемость vs Производительность
**Вопрос:** Почему оптимизации снижают общую производительность?
**Ответ:**
Использование `SCHED_FIFO` и жесткая привязка к ядру (CPU Affinity) мешают планировщику ОС эффективно распределять нагрузку.
- Привязка к ядру может оставить одно ядро перегруженным, а другие пустыми.
- Высокий приоритет FIFO может блокировать фоновые системные процессы.
Это снижает общую пропускную способность (throughput), но гарантирует минимальную задержку (latency) для конкретной важной задачи.

### 5. Жесткое реальное время
**Вопрос:** Достаточно ли этих техник для жесткого РВ? Что такое PREEMPT_RT?
**Ответ:**
Стандартного ядра Linux недостаточно для **жесткого** реального времени, так как внутри ядра существуют секции с отключенными прерываниями (спинлоки), которые могут создавать непредсказуемые задержки.
`PREEMPT_RT` — это набор патчей (Real-Time Patch), который:
1. Заменяет спинлоки на мьютексы (делает ядро вытесняемым).
2. Позволяет прерывать обработчики прерываний.
Это гарантирует детерминированное время реакции системы.